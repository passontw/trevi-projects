pipeline {
    agent {
        label 'MacMini_10.141.31.151'
    }
    
    environment {
        // Git 和 Harbor 設定
        GIT_CREDENTIAL = 'jenkins_deploy'
        HARBOR_REGISTRY = 'harbor.trevi-dev.cc'
        HARBOR_PROJECT = 'g38-dev'
        IMAGE_NAME = 'lottery-service-backend'
        DOCKERFILE_PATH = './deploy/lottery_service/Dockerfile'
        
        // Go 環境變數
        GO111MODULE = 'on'
        GOPROXY = 'https://goproxy.cn,direct'
        GOSUMDB = 'off'
    }
    
    stages {
        stage('Checkout') {
            steps {
                // Clean workspace
                cleanWs()
                // Checkout code
                checkout scm
            }
        }
        
        stage('Check Changes') {
            steps {
                script {
                    // 獲取最後兩次提交之間的更改文件
                    def changedFiles = ""
                    try {
                        changedFiles = sh(script: 'git diff --name-only HEAD^ HEAD || echo ""', returnStdout: true).trim()
                        echo "Changed files: ${changedFiles}"
                    } catch (Exception e) {
                        echo "Warning: Unable to determine changed files: ${e.message}"
                        echo "Proceeding with build anyway."
                        changedFiles = "unknown"
                    }
                    
                    // 檢查指定路徑是否有更改
                    def hasRelevantChanges = false
                    if (changedFiles != "unknown") {
                        def relevantChanges = sh(script: '''
                            git diff --name-only HEAD^ HEAD | grep -E "^cmd/lottery_service/main.go|^internal/|^pkg/.*/.*/" || echo ""
                        ''', returnStdout: true).trim()
                        
                        if (relevantChanges == '') {
                            echo "No changes in cmd/lottery_service/main.go, internal/*, or pkg/****/****/* paths."
                            echo "Build will continue for testing purposes."
                        } else {
                            echo "Relevant changes detected: ${relevantChanges}"
                            hasRelevantChanges = true
                        }
                    }
                    
                    // Store this for later use
                    env.HAS_RELEVANT_CHANGES = hasRelevantChanges.toString()
                }
            }
        }                
        
        stage('Test Environment') {
            steps {
                sh """
                    echo "Current directory: \$(pwd)"
                    echo "Directory listing:"
                    ls -la
                    echo "Go environment:"
                    go version || echo "Go not installed on agent"
                    echo "Project structure:"
                    find . -type f -name "*.go" | sort
                    echo "go.mod content:"
                    cat go.mod || echo "go.mod not found"
                """
            }
        }        
        
        stage('Build Docker Image') {
            steps {
                script {
                    // 定義 Docker 映像完整名稱
                    def imageTag = env.BUILD_NUMBER
                    env.FULL_IMAGE_NAME = "${env.HARBOR_REGISTRY}/${env.HARBOR_PROJECT}/${env.IMAGE_NAME}:${imageTag}"
                    env.LATEST_IMAGE_NAME = "${env.HARBOR_REGISTRY}/${env.HARBOR_PROJECT}/${env.IMAGE_NAME}:latest"
                    echo "Building image: ${env.FULL_IMAGE_NAME}"
                    
                    // 使用 --no-cache 選項確保每次構建都是乾淨的，並啟用詳細輸出
                    sh """
                        docker build -t ${env.FULL_IMAGE_NAME} . -f ${env.DOCKERFILE_PATH} \\
                            --no-cache --progress=plain
                    """
                    
                    // 為 latest 標籤打標
                    sh """
                        docker tag ${env.FULL_IMAGE_NAME} ${env.LATEST_IMAGE_NAME}
                    """
                    
                    echo "Docker image built successfully: ${env.FULL_IMAGE_NAME} and ${env.LATEST_IMAGE_NAME}"
                }
            }
        }
        
        stage('Push to Harbor') {
            steps {
                // Login to Harbor registry
                withCredentials([usernamePassword(credentialsId: 'harbor.trevi-dev.cc', passwordVariable: 'HARBOR_PWD', usernameVariable: 'HARBOR_USER')]) {
                    sh """
                        echo \"${HARBOR_PWD}\" | docker login \"https://${env.HARBOR_REGISTRY}\" -u \"${HARBOR_USER}\" --password-stdin
                    """
                }
                
                // Push 版本標籤和 latest 標籤
                sh """
                    docker push ${env.FULL_IMAGE_NAME}
                    docker push ${env.LATEST_IMAGE_NAME}
                """
                echo "Docker images pushed successfully: ${env.FULL_IMAGE_NAME} and ${env.LATEST_IMAGE_NAME}"
            }
        }                
    }
    
    post {
        always {
            script {
                // 不論成功或失敗，始終移除 Docker 映像
                echo "Cleaning up Docker images..."
                try {
                    if (env.FULL_IMAGE_NAME) {
                        sh "docker rmi ${env.FULL_IMAGE_NAME} || true"
                        echo "Removed Docker image: ${env.FULL_IMAGE_NAME}"
                    } else {
                        echo "FULL_IMAGE_NAME not defined, skipping image removal"
                    }
                    
                    if (env.LATEST_IMAGE_NAME) {
                        sh "docker rmi ${env.LATEST_IMAGE_NAME} || true"
                        echo "Removed Docker image: ${env.LATEST_IMAGE_NAME}"
                    }
                    
                    // 清理未使用的映像和暫存文件
                    sh "docker system prune -f || true"
                } catch (Exception e) {
                    echo "Warning: Failed to clean up Docker images: ${e.message}"
                }
            }
        }
        
        success {
            echo "Build and push completed successfully!"
            echo "Images: ${env.FULL_IMAGE_NAME} and ${env.LATEST_IMAGE_NAME}"
        }
        
        failure {
            echo "Build or push failed!"
        }
    }
}