pipeline {
    agent {
        label 'MacMini_10.141.31.151'
    }
    
    environment {
        // Git 和 Harbor 設定
        GIT_CREDENTIAL = 'jenkins_deploy'
        HARBOR_REGISTRY = 'harbor.trevi-dev.cc'
        HARBOR_PROJECT = 'g38-dev'
        IMAGE_NAME = 'lottery-service-backend'
        DOCKERFILE_PATH = './deploy/lottery_service/Dockerfile'
        
        // Go 環境變數
        GO111MODULE = 'on'
        GOPROXY = 'https://goproxy.cn,direct'
        GOSUMDB = 'off'
    }
    
    stages {
        stage('Checkout') {
            steps {
                // Clean workspace
                cleanWs()
                // Checkout code
                checkout scm
            }
        }
        
        stage('Check Changes') {
            steps {
                script {
                    // 獲取最後兩次提交之間的更改文件
                    def changedFiles = ""
                    try {
                        changedFiles = sh(script: 'git diff --name-only HEAD^ HEAD || echo ""', returnStdout: true).trim()
                        echo "Changed files: ${changedFiles}"
                    } catch (Exception e) {
                        echo "Warning: Unable to determine changed files: ${e.message}"
                        echo "Proceeding with build anyway."
                        changedFiles = "unknown"
                    }
                    
                    // 檢查指定路徑是否有更改
                    def hasRelevantChanges = false
                    if (changedFiles != "unknown") {
                        def relevantChanges = sh(script: '''
                            git diff --name-only HEAD^ HEAD | grep -E "^cmd/lottery_service/main.go|^internal/|^pkg/.*/.*/" || echo ""
                        ''', returnStdout: true).trim()
                        
                        if (relevantChanges == '') {
                            echo "No changes in cmd/lottery_service/main.go, internal/*, or pkg/****/****/* paths."
                            echo "Build will continue for testing purposes."
                        } else {
                            echo "Relevant changes detected: ${relevantChanges}"
                            hasRelevantChanges = true
                        }
                    }
                    
                    // Store this for later use
                    env.HAS_RELEVANT_CHANGES = hasRelevantChanges.toString()
                }
            }
        }
        
        stage('Prepare Build Info') {
            steps {
                script {
                    // Generate build timestamp
                    env.BUILD_TIMESTAMP = sh(script: 'date "+%Y%m%d%H%M%S"', returnStdout: true).trim()
                    
                    // Try to get git commit
                    try {
                        env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    } catch (Exception e) {
                        env.GIT_COMMIT_SHORT = "unknown"
                        echo "Could not get git commit: ${e.message}"
                    }
                    
                    // Set up the full image name
                    env.IMAGE_TAG = "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}-${BUILD_NUMBER}"
                    env.FULL_IMAGE_NAME = "${env.HARBOR_REGISTRY}/${env.HARBOR_PROJECT}/${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    
                    echo "Building image: ${env.FULL_IMAGE_NAME}"
                }
            }
        }
        
        stage('Prepare Dockerfile') {
            steps {
                script {
                    // 檢查 Dockerfile 是否存在
                    def dockerfileExists = fileExists(env.DOCKERFILE_PATH)
                    if (!dockerfileExists) {
                        error "Dockerfile not found at ${env.DOCKERFILE_PATH}"
                    }
                    
                    // 備份原 Dockerfile
                    sh "cp ${env.DOCKERFILE_PATH} ${env.DOCKERFILE_PATH}.bak"
                    
                    // 創建新的優化 Dockerfile
                    writeFile file: env.DOCKERFILE_PATH, text: '''# 構建階段
FROM golang:1.23-alpine AS builder

# 安裝必要工具
RUN apk add --no-cache gcc musl-dev git

# 設定工作目錄
WORKDIR /app

# 複製所有源代碼
COPY . .

# 修改 go.mod 以映射導入路徑
RUN echo "更新導入路徑" && \\
    if grep -q "module g38_lottery_service" go.mod; then \\
        echo "模組已正確設定"; \\
    else \\
        echo "修改 go.mod"; \\
        # 獲取當前模組名稱 \\
        MODULE_NAME=$(grep -E "^module" go.mod | awk '{print $2}') && \\
        # 添加路徑重新映射 \\
        echo "replacing module paths" && \\
        echo "replace $MODULE_NAME/internal => ./internal" >> go.mod && \\
        echo "replace $MODULE_NAME/g38_lottery_service => ./" >> go.mod && \\
        echo "replace g38_lottery_service => ./" >> go.mod && \\
        cat go.mod; \\
    fi

# 顯示當前目錄結構和 go.mod，用於調試
RUN echo "Workspace structure:" && ls -la && cat go.mod

# 使用 go.mod tidy 確保所有依賴正確
RUN go mod tidy

# 構建應用程序，顯示構建日誌
RUN go env && \\
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -v -o lottery_service ./cmd/lottery_service/main.go

# 最終階段
FROM alpine:latest

# 安裝必要的運行時依賴
RUN apk --no-cache add ca-certificates tzdata

# 設定工作目錄
WORKDIR /app

# 從構建階段複製編譯好的應用程序
COPY --from=builder /app/lottery_service .

# 暴露端口（根據您的應用需求調整）
EXPOSE 8080

# 運行命令
CMD ["./lottery_service"]
'''
                    echo "Created optimized Dockerfile for Go modules with path remapping"
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                // 修改 Docker 構建命令，添加必要的構建參數
                sh """
                    docker build -t ${env.FULL_IMAGE_NAME} . -f ${env.DOCKERFILE_PATH} \\
                        --build-arg MODULE_NAME=g38_lottery_service
                """
                echo "Docker image built successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
        
        stage('Push to Harbor') {
            steps {
                // Login to Harbor registry
                withCredentials([usernamePassword(credentialsId: 'harbor.trevi-dev.cc', passwordVariable: 'HARBOR_PWD', usernameVariable: 'HARBOR_USER')]) {
                    sh """
                        echo \"${HARBOR_PWD}\" | docker login \"https://${env.HARBOR_REGISTRY}\" -u \"${HARBOR_USER}\" --password-stdin
                    """
                }
                
                // Push the image to Harbor
                sh """
                    docker push ${env.FULL_IMAGE_NAME}
                """
                echo "Docker image pushed successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
        
        stage('Restore Dockerfile') {
            steps {
                script {
                    // 恢復原始 Dockerfile
                    sh "mv ${env.DOCKERFILE_PATH}.bak ${env.DOCKERFILE_PATH} || true"
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Only try to clean up if we have built the image
                if (env.FULL_IMAGE_NAME) {
                    try {
                        // Clean up - remove Docker image to save space
                        sh """
                            docker rmi ${env.FULL_IMAGE_NAME} || true
                        """
                        
                        // Logout from Harbor
                        sh """
                            docker logout ${env.HARBOR_REGISTRY} || true
                        """
                        
                        // 恢復原始 Dockerfile
                        sh "mv ${env.DOCKERFILE_PATH}.bak ${env.DOCKERFILE_PATH} || true"
                    } catch (Exception e) {
                        echo "Warning: Cleanup failed: ${e.message}"
                    }
                }
            }
        }
        
        success {
            echo "Build and push completed successfully!"
            echo "Image: ${env.FULL_IMAGE_NAME ?: 'No image was built'}"
        }
        
        failure {
            echo "Build or push failed!"
        }
    }
}