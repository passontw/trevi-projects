pipeline {
    agent {
        label 'MacMini_10.141.31.151'
    }
    
    environment {
        // Harbor registry information
        HARBOR_REGISTRY = 'harbor.trevi-dev.cc'
        HARBOR_PROJECT = 'g38-dev'
        IMAGE_NAME = 'lottery-service-backend'
        DOCKERFILE_PATH = './deploy/lottery_service/Dockerfile'
        
        // Go environment variables
        GOPATH = "${WORKSPACE}/gopath"
        GOMODCACHE = "${WORKSPACE}/gopath/pkg/mod"
        GO111MODULE = "on"
    }
    
    stages {
        stage('Checkout') {
            steps {
                // Clean workspace
                cleanWs()
                // Checkout code
                checkout scm
            }
        }
        
        stage('Check Changes') {
            steps {
                script {
                    // 獲取最後兩次提交之間的更改文件
                    def changedFiles = ""
                    try {
                        changedFiles = sh(script: 'git diff --name-only HEAD^ HEAD || echo ""', returnStdout: true).trim()
                        echo "Changed files: ${changedFiles}"
                    } catch (Exception e) {
                        echo "Warning: Unable to determine changed files: ${e.message}"
                        echo "Proceeding with build anyway."
                        changedFiles = "unknown"
                    }
                    
                    // 檢查指定路徑是否有更改
                    def hasRelevantChanges = false
                    if (changedFiles != "unknown") {
                        def relevantChanges = sh(script: '''
                            git diff --name-only HEAD^ HEAD | grep -E "^cmd/lottery_service/main.go|^internal/|^pkg/.*/.*/" || echo ""
                        ''', returnStdout: true).trim()
                        
                        if (relevantChanges == '') {
                            echo "No changes in cmd/lottery_service/main.go, internal/*, or pkg/****/****/* paths."
                            echo "Build will continue for testing purposes."
                        } else {
                            echo "Relevant changes detected: ${relevantChanges}"
                            hasRelevantChanges = true
                        }
                    }
                    
                    // Store this for later use
                    env.HAS_RELEVANT_CHANGES = hasRelevantChanges.toString()
                }
            }
        }
        
        stage('Prepare Build Info') {
            steps {
                script {
                    // Generate build timestamp
                    env.BUILD_TIMESTAMP = sh(script: 'date "+%Y%m%d%H%M%S"', returnStdout: true).trim()
                    
                    // Try to get git commit
                    try {
                        env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    } catch (Exception e) {
                        env.GIT_COMMIT_SHORT = "unknown"
                        echo "Could not get git commit: ${e.message}"
                    }
                    
                    // Set up the full image name
                    env.IMAGE_TAG = "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}-${BUILD_NUMBER}"
                    env.FULL_IMAGE_NAME = "${env.HARBOR_REGISTRY}/${env.HARBOR_PROJECT}/${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    
                    echo "Building image: ${env.FULL_IMAGE_NAME}"
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                // 修改 Dockerfile 以正確處理 Go modules
                sh '''
                    # 確保構建上下文正確
                    cd ${WORKSPACE}
                    
                    # 構建 Docker 映像
                    docker build -t ${FULL_IMAGE_NAME} . -f ${DOCKERFILE_PATH} \\
                        --build-arg GO111MODULE=on \\
                        --build-arg GOPROXY=https://goproxy.cn,direct \\
                        --build-arg GOSUMDB=off
                '''
                
                echo "Docker image built successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
        
        stage('Push to Harbor') {
            steps {
                // Login to Harbor registry
                withCredentials([usernamePassword(credentialsId: 'harbor-credentials', passwordVariable: 'HARBOR_PASSWORD', usernameVariable: 'HARBOR_USERNAME')]) {
                    sh '''
                        echo ${HARBOR_PASSWORD} | docker login ${HARBOR_REGISTRY} -u ${HARBOR_USERNAME} --password-stdin
                    '''
                }
                
                // Push the image to Harbor
                sh '''
                    docker push ${FULL_IMAGE_NAME}
                '''
                
                echo "Docker image pushed successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
    }
    
    post {
        always {
            script {
                // Only try to clean up if we have built the image
                if (env.FULL_IMAGE_NAME) {
                    try {
                        // Clean up - remove Docker image to save space
                        sh '''
                            docker rmi ${FULL_IMAGE_NAME} || true
                        '''
                        
                        // Logout from Harbor
                        sh '''
                            docker logout ${HARBOR_REGISTRY} || true
                        '''
                    } catch (Exception e) {
                        echo "Warning: Cleanup failed: ${e.message}"
                    }
                }
            }
        }
        
        success {
            echo "Build and push completed successfully!"
            echo "Image: ${env.FULL_IMAGE_NAME ?: 'No image was built'}"
        }
        
        failure {
            echo "Build or push failed!"
        }
    }
}