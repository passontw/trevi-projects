pipeline {
    agent {
        label 'MacMini_10.141.31.151'
    }
    
    stages {
        stage('Checkout') {
            steps {
                // Clean workspace
                cleanWs()
                // Checkout code from GitLab
                checkout scm
            }
        }
        
        stage('Check Changes') {
            steps {
                script {
                    // Get changed files - ensure git repo is properly checked out first
                    def hasChanges = false
                    try {
                        def changedFiles = sh(script: 'git diff --name-only HEAD^ HEAD || true', returnStdout: true).trim()
                        echo "Changed files: ${changedFiles}"
                        
                        // Check if specified paths have changed
                        def hasRelevantChanges = sh(script: '''
                            git diff --name-only HEAD^ HEAD | grep -E "^cmd/lottery_service/main.go|^internal/|^pkg/.*/.*/" || true
                        ''', returnStdout: true).trim()
                        
                        if (hasRelevantChanges == '') {
                            echo "No changes in cmd/lottery_service/main.go, internal/*, or pkg/****/****/* paths. Build will continue anyway for testing."
                            // We don't exit early for testing purposes
                            // currentBuild.result = 'SUCCESS'
                            // error("Skipping build due to no relevant changes")
                        } else {
                            echo "Relevant changes detected. Proceeding with build."
                            hasChanges = true
                        }
                    } catch (Exception e) {
                        echo "Error checking git changes: ${e.message}. Proceeding with build anyway."
                    }
                    
                    // Store this for later use
                    env.HAS_RELEVANT_CHANGES = hasChanges.toString()
                }
            }
        }
        
        stage('Prepare Build Info') {
            steps {
                script {
                    // Generate build timestamp
                    env.BUILD_TIMESTAMP = sh(script: 'date "+%Y%m%d%H%M%S"', returnStdout: true).trim()
                    
                    // Try to get git commit, but don't fail if not available
                    try {
                        env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    } catch (Exception e) {
                        env.GIT_COMMIT_SHORT = "unknown"
                        echo "Could not get git commit: ${e.message}"
                    }
                    
                    // Set up the full image name
                    env.HARBOR_REGISTRY = 'harbor.trevi-dev.cc'
                    env.HARBOR_PROJECT = 'g38-dev'
                    env.IMAGE_NAME = 'lottery-service-backend'
                    env.IMAGE_TAG = "${env.BUILD_TIMESTAMP}-${env.GIT_COMMIT_SHORT}-${BUILD_NUMBER}"
                    env.FULL_IMAGE_NAME = "${env.HARBOR_REGISTRY}/${env.HARBOR_PROJECT}/${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    env.DOCKERFILE_PATH = './deploy/lottery_service/Dockerfile'
                    
                    echo "Building image: ${env.FULL_IMAGE_NAME}"
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                sh """
                    docker build -t ${env.FULL_IMAGE_NAME} . -f ${env.DOCKERFILE_PATH}
                """
                echo "Docker image built successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
        
        stage('Push to Harbor') {
            steps {
                // Login to Harbor registry
                withCredentials([usernamePassword(credentialsId: 'harbor-credentials', passwordVariable: 'HARBOR_PASSWORD', usernameVariable: 'HARBOR_USERNAME')]) {
                    sh """
                        echo ${HARBOR_PASSWORD} | docker login ${env.HARBOR_REGISTRY} -u ${HARBOR_USERNAME} --password-stdin
                    """
                }
                
                // Push the image to Harbor
                sh """
                    docker push ${env.FULL_IMAGE_NAME}
                """
                echo "Docker image pushed successfully: ${env.FULL_IMAGE_NAME}"
            }
        }
    }
    
    post {
        always {
            script {
                // Only try to clean up if we have built the image
                if (env.FULL_IMAGE_NAME) {
                    try {
                        // Clean up - remove Docker image to save space
                        sh """
                            docker rmi ${env.FULL_IMAGE_NAME} || true
                        """
                        
                        // Logout from Harbor
                        sh """
                            docker logout ${env.HARBOR_REGISTRY} || true
                        """
                    } catch (Exception e) {
                        echo "Warning: Cleanup failed: ${e.message}"
                    }
                }
            }
        }
        
        success {
            echo "Build and push completed successfully!"
            echo "Image: ${env.FULL_IMAGE_NAME ?: 'No image was built'}"
        }
        
        failure {
            echo "Build or push failed!"
        }
    }
}